import { FloatingMenu, ItemSeat } from "@sochipark-apps-mono-frontend/ui";
import { useState, useRef, useEffect, useCallback } from "react";
import "./styles.scss";

type SeatPosition = {
  row: number;
  seat: number;
};

type Sector = "A" | "B" | "C" | "D" | "E";
type SeatStatus = "disabled" | "blocked" | "tempBlocked" | "reserved";

export const HallManagement = () => {
  const ROWS_COUNT = 30;
  const SEATS_PER_ROW = 53;

  // Состояния для выделения
  const [selectionStart, setSelectionStart] = useState<SeatPosition | null>(null);
  const [selectionEnd, setSelectionEnd] = useState<SeatPosition | null>(null);
  const [isSelecting, setIsSelecting] = useState(false);
  const [selectionBox, setSelectionBox] = useState<DOMRect | null>(null);
  const [startPosition, setStartPosition] = useState<{ x: number; y: number } | null>(null);
  
  // Объединенные состояния для статусов мест
  const [seatsStatus, setSeatsStatus] = useState<Record<string, SeatStatus>>({});
  const [selectedSeats, setSelectedSeats] = useState<Record<string, true>>({});
  
  // Состояния для секторов
  const [currentSector, setCurrentSector] = useState<Sector>("A");
  const [seatsSectors, setSeatsSectors] = useState<Record<string, Sector>>(() => {
    const initialSectors: Record<string, Sector> = {};
    for (let row = 0; row < ROWS_COUNT; row++) {
      for (let seat = 0; seat < SEATS_PER_ROW; seat++) {
        initialSectors[`${row}-${seat}`] = "A";
      }
    }
    return initialSectors;
  });

  // Рефы
  const hallWrapperRef = useRef<HTMLDivElement>(null);
  const lastRowRef = useRef<HTMLDivElement>(null);

  const resetSelection = useCallback(() => {
    setSelectedSeats({});
    setSelectionStart(null);
    setSelectionEnd(null);
    setIsSelecting(false);
    setSelectionBox(null);
    setStartPosition(null);
  }, []);

  // Обработчик событий клавиатуры
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        resetSelection();
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [resetSelection]);

  // Получение места по координатам
  const getSeatAtPosition = useCallback((clientX: number, clientY: number) => {
    const element = document.elementFromPoint(clientX, clientY);
    if (!element || !element.closest(".item-seat")) return null;

    const seatElement = element.closest(".item-seat");
    const row = seatElement?.getAttribute("data-row");
    const seat = seatElement?.getAttribute("data-seat");

    return row && seat ? { row: parseInt(row), seat: parseInt(seat) } : null;
  }, []);

  // Обновление рамки выделения
  const updateSelectionBox = useCallback(
    (startX: number, startY: number, endX: number, endY: number) => {
      const left = Math.min(startX, endX);
      const top = Math.min(startY, endY);
      const width = Math.abs(endX - startX);
      const height = Math.abs(endY - startY);

      setSelectionBox(new DOMRect(left, top, width, height));
    },
    []
  );

  // Проверка, выбрано ли место
  const isSeatSelected = useCallback(
    (rowIndex: number, seatIndex: number) => {
      if (isSelecting && selectionStart && selectionEnd) {
        const minRow = Math.min(selectionStart.row, selectionEnd.row);
        const maxRow = Math.max(selectionStart.row, selectionEnd.row);
        const minSeat = Math.min(selectionStart.seat, selectionEnd.seat);
        const maxSeat = Math.max(selectionStart.seat, selectionEnd.seat);

        return (
          rowIndex >= minRow &&
          rowIndex <= maxRow &&
          seatIndex >= minSeat &&
          seatIndex <= maxSeat
        );
      }

      return !!selectedSeats[`${rowIndex}-${seatIndex}`];
    },
    [isSelecting, selectionStart, selectionEnd, selectedSeats]
  );

  // Получение иконки для места
  const getSeatIcon = useCallback(
    (rowIndex: number, seatIndex: number) => {
      const seatKey = `${rowIndex}-${seatIndex}`;
      const status = seatsStatus[seatKey];

      switch (status) {
        case 'disabled': return 'OFF';
        case 'blocked': return 'BLOCK';
        case 'tempBlocked': return 'TEMP_BLOCK';
        case 'reserved': return 'BOOK';
        default: return null;
      }
    },
    [seatsStatus]
  );

  // Обработчик клика по месту
  const handleSeatClick = useCallback(
    (e: React.MouseEvent, rowIndex: number, seatIndex: number) => {
      e.stopPropagation();

      const seatKey = `${rowIndex}-${seatIndex}`;
      const newSelectedSeats = { ...selectedSeats };

      if (e.ctrlKey || e.metaKey) {
        // Добавляем/удаляем место при зажатом Ctrl/Cmd
        if (newSelectedSeats[seatKey]) {
          delete newSelectedSeats[seatKey];
        } else {
          newSelectedSeats[seatKey] = true;
        }
      } else if (e.shiftKey && Object.keys(selectedSeats).length > 0) {
        // Выделяем диапазон при зажатом Shift
        const firstSelected = Object.keys(selectedSeats)[0];
        const [firstRow, firstSeat] = firstSelected.split("-").map(Number);

        const minRow = Math.min(firstRow, rowIndex);
        const maxRow = Math.max(firstRow, rowIndex);
        const minSeat = Math.min(firstSeat, seatIndex);
        const maxSeat = Math.max(firstSeat, seatIndex);

        for (let r = minRow; r <= maxRow; r++) {
          for (let s = minSeat; s <= maxSeat; s++) {
            newSelectedSeats[`${r}-${s}`] = true;
          }
        }
      } else {
        // Одиночный клик - выделяем только это место
        Object.keys(newSelectedSeats).forEach(key => delete newSelectedSeats[key]);
        newSelectedSeats[seatKey] = true;
      }

      setSelectedSeats(newSelectedSeats);
      setSelectionStart({ row: rowIndex, seat: seatIndex });
      setSelectionEnd({ row: rowIndex, seat: seatIndex });
    },
    [selectedSeats]
  );

  // Обработчики событий мыши для выделения области
  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      if (e.button !== 0) return; // Только левая кнопка мыши

      const seat = getSeatAtPosition(e.clientX, e.clientY);

      // Если клик не по месту или с зажатой клавишей Ctrl/Shift - не начинаем выделение
      if (!seat || e.ctrlKey || e.metaKey || e.shiftKey) return;

      setIsSelecting(true);
      setSelectionStart(seat);
      setSelectionEnd(seat);
      setStartPosition({ x: e.clientX, y: e.clientY });
    },
    [getSeatAtPosition]
  );

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isSelecting || !startPosition) return;

      updateSelectionBox(
        startPosition.x,
        startPosition.y,
        e.clientX,
        e.clientY
      );

      const seat = getSeatAtPosition(e.clientX, e.clientY);
      if (seat) {
        setSelectionEnd(seat);
      }
    },
    [isSelecting, startPosition, updateSelectionBox, getSeatAtPosition]
  );

  const handleMouseUp = useCallback(() => {
    if (!isSelecting) return;

    if (selectionStart && selectionEnd) {
      const newSelectedSeats: Record<string, true> = {};
      const minRow = Math.min(selectionStart.row, selectionEnd.row);
      const maxRow = Math.max(selectionStart.row, selectionEnd.row);
      const minSeat = Math.min(selectionStart.seat, selectionEnd.seat);
      const maxSeat = Math.max(selectionStart.seat, selectionEnd.seat);

      for (let row = minRow; row <= maxRow; row++) {
        for (let seat = minSeat; seat <= maxSeat; seat++) {
          newSelectedSeats[`${row}-${seat}`] = true;
        }
      }

      setSelectedSeats(newSelectedSeats);
    }

    setIsSelecting(false);
    setSelectionBox(null);
    setStartPosition(null);
  }, [isSelecting, selectionStart, selectionEnd]);

  // Подписка на глобальные события мыши
  useEffect(() => {
    if (isSelecting) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    }

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [isSelecting, handleMouseMove, handleMouseUp]);

  // Обработчик изменения диапазона мест
  const handleSeatRangeChange = useCallback((from: string, to: string) => {
    if (!from && !to) {
      setSelectedSeats({});
      return;
    }

    const fromNum = parseInt(from);
    const toNum = parseInt(to);

    if (isNaN(fromNum)) return;

    const newSelectedSeats: Record<string, true> = {};
    const start = Math.min(fromNum, toNum || fromNum);
    const end = Math.max(fromNum, toNum || fromNum);

    for (let seatNum = start; seatNum <= end; seatNum++) {
      const row = Math.floor((seatNum - 1) / SEATS_PER_ROW);
      const seat = (seatNum - 1) % SEATS_PER_ROW;

      if (row >= 0 && row < ROWS_COUNT && seat >= 0 && seat < SEATS_PER_ROW) {
        newSelectedSeats[`${row}-${seat}`] = true;
      }
    }

    setSelectedSeats(newSelectedSeats);
  }, []);

  // Обработчик действий с местами
  const handleActionClick = useCallback(
    (action: "disable" | "block" | "temporaryBlock" | "reserve" | "clear") => {
      const selectedSeatKeys = Object.keys(selectedSeats);
      if (selectedSeatKeys.length === 0) return;

      setSeatsStatus(prev => {
        const newStatus = { ...prev };
        
        if (action === 'clear') {
          selectedSeatKeys.forEach(key => delete newStatus[key]);
        } else {
          const statusMap = {
            disable: 'disabled',
            block: 'blocked',
            temporaryBlock: 'tempBlocked',
            reserve: 'reserved'
          } as const;
          
          selectedSeatKeys.forEach(key => {
            newStatus[key] = statusMap[action];
          });
        }
        
        return newStatus;
      });
    },
    [selectedSeats]
  );

  // Обработчик изменения сектора
  const handleSectorChange = useCallback(
    (sector: Sector) => {
      setCurrentSector(sector);

      const selectedSeatKeys = Object.keys(selectedSeats);
      if (selectedSeatKeys.length > 0) {
        setSeatsSectors(prev => {
          const newSeatsSectors = { ...prev };
          selectedSeatKeys.forEach(seat => {
            newSeatsSectors[seat] = sector;
          });
          return newSeatsSectors;
        });
      }
    },
    [selectedSeats]
  );

  // Обработчик кликов вне зала
  useEffect(() => {
    const handleDocumentClick = (e: MouseEvent) => {
      const target = e.target as HTMLElement;

      if (hallWrapperRef.current && hallWrapperRef.current.contains(target)) {
        return;
      }

      resetSelection();
    };

    document.addEventListener("mousedown", handleDocumentClick);

    return () => document.removeEventListener("mousedown", handleDocumentClick);
  }, [resetSelection]);

  return (
    <div className="hall-management-wrapper" ref={hallWrapperRef}>
      <div className="hall-management" onMouseDown={handleMouseDown}>
        {selectionBox && isSelecting && (
          <div
            className="selection-box"
            style={{
              position: "fixed",
              left: `${selectionBox.x}px`,
              top: `${selectionBox.y}px`,
              width: `${selectionBox.width}px`,
              height: `${selectionBox.height}px`,
            }}
          />
        )}

        {Array.from({ length: ROWS_COUNT }).map((_, rowIndex) => (
          <div
            key={`row-${rowIndex}`}
            className="hall-row"
            ref={rowIndex === ROWS_COUNT - 1 ? lastRowRef : null}
          >
            <div className="row-number left">{rowIndex + 1}</div>
            {Array.from({ length: SEATS_PER_ROW }).map((_, seatIndex) => {
              const seatNumber = rowIndex * SEATS_PER_ROW + seatIndex + 1;
              return (
                <ItemSeat
                  key={`seat-${rowIndex}-${seatIndex}`}
                  sector={seatsSectors[`${rowIndex}-${seatIndex}`]}
                  icon={getSeatIcon(rowIndex, seatIndex)}
                  isDisabled={seatsStatus[`${rowIndex}-${seatIndex}`] === 'disabled'}
                  isSelected={isSeatSelected(rowIndex, seatIndex)}
                  onClick={(e) => handleSeatClick(e, rowIndex, seatIndex)}
                  data-row={rowIndex}
                  data-seat={seatIndex}
                  seatNumber={seatNumber}
                />
              );
            })}
            <div className="row-number right">{rowIndex + 1}</div>
          </div>
        ))}
      </div>
      <FloatingMenu
        selectedSeats={new Set(Object.keys(selectedSeats))}
        onSeatRangeChange={handleSeatRangeChange}
        onActionClick={handleActionClick}
        onSectorChange={handleSectorChange}
        currentSector={currentSector}
      />
    </div>
  );
};